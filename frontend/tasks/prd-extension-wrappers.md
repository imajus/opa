# 1. Introduction / Overview

Professional traders, dApp developers, and power users require a simple way to compose sophisticated 1inch Limit-Order-Protocol (LOP) strategies without learning low-level ABI details. This feature delivers **JavaScript extension wrappers**—small, declarative objects that describe each LOP extension (e.g., `ChainlinkCalculator`, `GasStation`) and provide a single `build()` helper to transform user-supplied parameters into a fully-formed LOP **Extension** instance (using the 1inch Limit Order SDK). These wrappers will act as the building blocks for an upcoming no-code web strategy composer UI.

# 2. Goals

1. Offer a high-level, ESM-friendly API for every LOP extension.
2. Abstract away Zod schema validation and 1inch SDK manipulation so end-users focus only on business parameters.
3. Facilitate reuse across browser and Node environments.
4. Provide unit-tested, shareable blueprints that can be stored or transmitted as JSON.

# 3. User Stories

1. **Trader** – _As a professional trader, I want to assemble a custom strategy with drag-and-drop building blocks, so I can execute orders that CEXes cannot support._
2. **Web3 Developer** – _As a developer, I want to generate a static JSON blueprint once and embed it in my dApp, so users can easily submit complex orders without deep protocol knowledge._
3. **Power User** – _As an experienced crypto user, I want to craft a gas-less swap blueprint and share it with a friend, so they can simply sign & broadcast the order._

# 4. Functional Requirements

1. **Extension Object Definition**  
   Each wrapper exports a default object containing:  
   a. `name`: short identifier (e.g., `gasStation`)  
   b. `description`: brief purpose sentence  
   c. `hooks`: object of utilised hooks (`makerAmount`, `takerAmount`, `preInteraction`, `postInteraction`) as keys and their input parameter Zod schemas as values (each field must support name, description, type, default value, and other Zod constraints).
2. **`build()` Helper**  
   Exported function signature:  
   `build(params: object) -> Extension`  
   • `params`: object with parameters for each supported hook
   • returns `extension`: 1Inch Limit Order SDK Extension object to attach to the order.
3. **Unit Tests** – Cover happy path and invalid parameter scenarios for every wrapper (≥90% line coverage).
4. **Packaging** – Published as ESM-only package; no bundler config required at this stage.

# 5. SDK / Tooling

- Language: **JavaScript (ES Modules)**
- Validation: **Zod** for schema definitions & checking
- Protocol Library: **1inch Limit Order SDK** (import via npm and fetch docs via context7)
- Testing: **Mocha** for unit tests
- Linting: **ESLint** with pre-configured standard rules

# 6. Non-Goals (Out of Scope)

1. UI components, forms, or drag-and-drop interface.
2. Network calls, wallet signing, or on-chain broadcasting logic.
3. Enumerating all available extensions or serialising entire LOP orders (handled elsewhere).
4. Input parameters are expected to be validated against schemas before calling the `build()` helper

# 7. Design Considerations (Optional)

- **Naming** – Prefer concise snake-case names (`station`, `build`, `extension`).
- **Folder Structure**
  ```
  src/
    extensions/
      gas-station.js
      chainlink-calculator.js
      ...
  ```
- **Documentation** – JSDoc comments generated into md files via `jsdoc`.

# 8. Technical Considerations (Optional)

- Must compile under both Node ≥18 (ESM) and modern browsers via native import maps or external bundlers.
- Consider tree-shakable exports to minimise bundle size.

# 9. Success Metrics

1. **Correctness** – All unit tests pass and wrappers return valid Extension objects accepted by the SDK.

# 10. Optional / Stretch Goals

- Provide autogenerated **TypeScript declaration files** for stronger typing.
- Release a **CLI** to scaffold custom extension wrappers.
- Integrate **schema-driven form generation** for rapid UI prototyping.

# 11. Open Questions

1. Should we version wrapper packages in lock-step with the 1inch SDK? - no, skip this for now
2. How will multi-hook extensions coordinate overlapping parameters? - the outer system will ensure to not stack multiple extensions with the same or overlapping hooks
3. Is runtime locale/i18n support required for descriptions? - just english
